import { IGeometry, GeometryType, IFeature, IPopupInfo } from '@esri/arcgis-rest-types'
import { IAttachmentInfo } from '@esri/arcgis-rest-feature-layer'
// only used as types
import { DataSourceManager, IMDataSourceJson, IMDataSourceSchema, IMReversedDataSourceSchema, IntlShape, IMDataSourceInfo, ServiceDefinition, ImmutableObject, ImmutableArray } from 'jimu-core'
import { JimuFeatureLayerView } from 'jimu-arcgis' // only used as type

/**
 * All data source status is here, including data source instance status and data status (for QueriableDataSource).
 * * Instance status includes: NotCreated, Created, CreateError. <br/>
 *    When a data source is requested to be created, it is set to `NotCreated` at first.
 *    If a data source has never been used, there is no data source status.
 * * Data status includes: NotReady, Unloaded, Loading, Loaded, LoadError. <br/>
 *    When a QueriableDataSource is created, it is set as `NotReady` or `Unloaded` at first.
 *    If the data source is generated by widgets, the initial status will be `NotReady`, otherwise the initial status will be `Unloaded`.
 *    When widgets are ready to generate data, that is to say, the data source is ready to do query, widgets will change the status from `NotReady` to `Unloaded`.
 *    When widgets are not ready to generate data, widgets will change the status back to `NotReady`,
 *    then framework will help to clear source records, records and cache in data source instance.
 *    If `load()` is invoked, it will be set as `Loading`. If data is returned, it will be set as `Loaded`.
 *    If an error occurs, it will be set as `LoadError`.
 */
export enum DataSourceStatus {
  // Instance status.
  NotCreated = 'NOT_CREATED',
  Created = 'CREATED',
  CreateError = 'CREATE_ERROR',

  // Data status.
  /**
   * NotReady is for widget output data source only.
   * When output data source instance is created, the data is not ready for use.
   * Widget should dispatch an action (DataSourceStatusChanged) to make the data source ready for use.
   * If a data source status is not ready, the query should return an empty result.
   */
  NotReady = 'NOT_READY',
  Unloaded = 'UNLOADED',
  Loading = 'LOADING',
  Loaded = 'LOADED',
  LoadError = 'LOAD_ERROR',

  // Save status.
  /** @ignore */
  Saving = 'SAVING',
  /** @ignore */
  Saved = 'SAVED',
  /** @ignore */
  SaveError = 'SAVE_ERROR',

  // For remote push(stream) data sources.
  /** @ignore */
  Closed = 'CLOSED',
  /** @ignore */
  Connecting = 'CONNECTING',
  /** @ignore */
  Connected = 'CONNECTED',
  /** @ignore */
  Closing = 'CLOSING',

  // For client DS, we don't define status.
}

/**
 * The data source types that `jimu-core` supports.
 */
export enum DataSourceTypes {
  /** @ignore */
  SimpleLocal = 'SIMPLE_LOCAL',
  /** @ignore */
  CSV = 'CSV',

  /**
   * FeatureLayer data source is a `QueriableDataSource`, which is used to query ArcGIS feature service.
   * See {@link FeatureLayerDataSource}
   */
  FeatureLayer = 'FEATURE_LAYER',
  /**
   * See {@link SceneLayerDataSource}
   */
  SceneLayer = 'SCENE_LAYER',
  /**
   * GroupLayer data source is a data source set that may have child data sources. It is from group layer in a map service or a webmap/webscene.
   */
  GroupLayer = 'GROUP_LAYER',
  /**
   * FeatureService data source is a data source set that may have child data sources. It is from the feature service.
   */
  FeatureService = 'FEATURE_SERVICE',
  /**
   * GroupLayer data source is a data source set that may have child data sources. It is from the map service.
   */
  MapService = 'MAP_SERVICE',
  /**
   * SceneLayer data source is a data source set that may have child data sources. It is from the scene service.
   */
  SceneService = 'SCENE_SERVICE'
}

/**
 * For now, we only support some layer service types.
 */
export enum SupportedLayerServiceTypes {
  // single layer service under map service or feature service
  FeatureLayer = 'Feature Layer',
  Table = 'Table',
  GroupLayer = 'Group Layer',

  // single layer service under scene service
  SceneLayerPoint = 'Point',
  SceneLayer3DObject = '3DObject'
}

/**
 * For now, we only support some service types.
 */
export enum SupportedServiceTypes {
  // [Feature Service](https://developers.arcgis.com/rest/services-reference/feature-service.htm)
  FeatureService = 'FeatureServer',
  // [Map Service](https://developers.arcgis.com/rest/services-reference/hosted-map-service.htm)
  MapService = 'MapServer',
  // [Scene Service](https://developers.arcgis.com/rest/services-reference/scene-service.htm)
  SceneService = 'SceneServer'
}

/**
 * For now, we only support some portal item types.
 * Please see [Items and item types](https://developers.arcgis.com/rest/users-groups-and-items/items-and-item-types.htm).
 */
export enum SupportedItemTypes {
  WebMap = 'Web Map',
  WebScene = 'Web Scene',
  FeatureService = 'Feature Service',
  MapService = 'Map Service',
  SceneService = 'Scene Service',
  FeatureCollection = 'Feature Collection'
}

/**
 * For now, we only support some layer types.
 * Please see [Layer](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-Layer.html).
 */
export enum SupportedLayerTypes {
  FeatureLayer = 'feature',
  MapImageLayer = 'map-image',
  TileLayer = 'tile',
  GroupLayer = 'group',
  SceneLayer = 'scene'
}

/**
 * Data source factory is used to create data source.
 */
export interface DataSourceFactory {
  createDataSource: (options: DataSourceConstructorOptions) => DataSource
}

/**
 * A data record represents a record in a data source.
 */
export interface DataRecord {
  /** A reference of the data source object that has this record. */
  dataSource: DataSource

  /**
   * The data is a plain object. The format is {key: value}, and the key is "jimuFieldName".
   *
   * The data before mapping use this schema: {fieldName: value}. We need to return this schema: {jimuFieldName: value}.
   */
  getData: () => any

  /** @ignore */
  getDataBeforeMapping: () => any

  getFormattedData: (intl: IntlShape) => any

  getFieldValue: (jimuFieldName: string) => any
  getFormattedFieldValue: (jimuFieldName: string, intl: IntlShape) => string

  /** @ignore */
  convertBeforeMappingDataToData: (beforeMappingData: any) => any

  /**
   * Return the data in JSON format, which is used to serialize data, and the key is "jimuFieldName".
   */
  toJson: () => any

  getId: () => string
  setId: (id: string) => void

  getGeometry: () => IGeometry

}

/** @ignore */
export interface AttachmentInfo extends IAttachmentInfo {
  url?: string
}

/** @ignore */
export interface AttachmentQueryOptions{
  attachmentTypes: string[]
  url: string
  featureId: number | string
}

// Refer to: https://developers.arcgis.com/javascript/latest/api-reference/esri-tasks-support-FeatureSet.html
export interface DataRecordSet{
  records: DataRecord[]
  // The jimuFieldName.
  fields?: string[]

  // The data source that the data record set comes from.
  dataSource?: DataSource
}

/**
 * The result of data source's query method.
 */
export interface QueryResult{
  // The query parameters that generate the result.
  queryParams: IMQueryParams

  records?: DataRecord[]
  // The jimuFieldName.
  fields?: string[]

  count?: number
  // Source version of data source.
  sourceVersion?: number
}

/**
 * Query scope defines which data is returned when the query is executed in addition to the query parameters.
 */
export enum QueryScope{
  /** Use the query parameters directly to query. */
  InAllData = 'IN_ALL_DATA',

  /** Use the query parameters and the filters configured in exb to query. */
  InRemoteConfigView = 'IN_REMOTE_CONFIG_VIEW',

  /** Use the query parameters and the configured filters in data source and filters configured in exb to query. */
  InConfigView = 'IN_CONFIG_VIEW',

  /** Use all of the appliyed query parameters to query. */
  InRuntimeView = 'IN_RUNTIME_VIEW'
}

/**
 * Options when calling data source's load method.
 */
export interface QueryOptions{
  scope?: QueryScope

  /** For load only.
   *  For local data source, you can use local id as widget id.
   */
  widgetId?: string

  /** Force the query even if  the query parameters have not changed. */
  refresh?: boolean

  /**
   * When execute query, the matched query is excluded.
   * Valid in runtime scope only.
   */
  excludeQuery?: WidgetDataSourcePair
}

export interface WidgetDataSourcePair{
  dataSourceId: string
  widgetId: string
}

/** The base query parameter interface. */
export interface QueryParams{
  // The first page is 1, not 0.
  page?: number
  pageSize?: number
}
export type IMQueryParams = ImmutableObject<QueryParams>

/**
 * Query parameter which supports SQL.
 */
export interface SqlQueryParams extends QueryParams{
  where?: string
  outFields?: string[]
  orderByFields?: string[]
  groupByFieldsForStatistics?: string[]
}
export type IMSqlQueryParams = ImmutableObject<SqlQueryParams>

/**
 * Query parameters for featuer layer.
 */
export interface FeatureLayerQueryParams extends SqlQueryParams{
  objectIds?: number[]
  geometry?: IGeometry
  returnGeometry?: boolean
  geometryPrecision?: number
  outStatistics?: StatisticDefinition[]
  returnZ?: boolean
  returnM?: boolean
  gdbVersion?: string
  sqlFormat?: 'none' | 'standard' | 'native'
}
export type IMFeatureLayerQueryParams = ImmutableObject<FeatureLayerQueryParams>

export interface StatisticDefinition{
  statisticType: 'count' | 'sum' | 'min' | 'max' | 'avg' | 'stddev' | 'var'
  onStatisticField: string
  outStatisticFieldName: string
}

interface ParentDataSource{
  getChildDataSources?: () => DataSource[]

  /**
   * Get child data source by `jimuChildId`, you can get `jimuChildId` by using `getJimuChildId()`.
   * @ignore
   */
  getChildDataSource?: (jimuChildId: string) => DataSource

  /**
   * Get the actual data source id by `jimuChildId`.
   * @ignore
   */
  getChildDataSourceId?: (jimuChildId: string) => string

  /**
   * @ignore
   * The jimu child id is similar to the jimuFieldName, and widgets should use the jimuChildId instead of the childId to make data mapping work.
   */
  getJimuChildId?: (childId: string) => string[]
}

interface ChildDataSource{
  /**
   * Null means it's root data source.
   */
  parentDataSource: DataSource

  jimuChildId: string

  getRootDataSource: () => DataSource
}

interface DataViewOperations{
  /** Return all data views created from a main data source. */
  getDataViews: () => DataSource[]
  getDataView: (dataViewId: string) => DataSource
}

interface LocalDataSourceOperations{
  /** Return all local data sources created from a main data source or data view. */
  getLocalDataSources: () => DataSource[]
  getLocalDataSource: (localId: string) => DataSource
}

/**
 * The data views will share the schema of the main data source it belongs to.
 */
interface DataViewDataSource{
  belongToDataSource?: DataSource
  getMainDataSource: () => DataSource

  /**
   * The data view id configured in Json.
   */
  dataViewId?: string
}

/**
 * @ignore
 * These methods will update the source data of data source.
 *
 * The data source object provides an interface interact with its source,
 * the source 1. may come from AGOL/portal item or a remote database, 2. may come from an array directly.
 * If the source comes from AGOL/portal item or a remote database, these operations will use JS API or REST API to apply edits to it.
 * If the source comes from an array directly, will save it in `sourceRecords` and these operations will edit the `sourceRecords`.
 *
 * The data source object also contains a subset of its source, the subset is saved in `records` and loaded from source.
 * To update the subset, please use `setRecords()`, to update the source, please use these operations.
 * To get the subset, please use `getRecords()`, to get the source:
 *   - for data source which comes from an array directly, please use `getSourceRecords()`,
 *   - for data source which comes from AGOL/portal item or a remote database:
 *     - for queriable data source, please use `query()` or `load()`,
 *     - for stream data source, please use `onData` (TBD).
 */
interface DataSourceEditSourceOperations{
  updateRecords: (records: DataRecord[]) => Promise<boolean>
  addRecord: (record: DataRecord) => Promise<DataRecord>
  updateRecord: (record: DataRecord) => Promise<boolean>
  deleteRecord: (index: number) => Promise<boolean>
  deleteRecordById: (id: string) => Promise<boolean>
}

/**
 * The interface for all data sources.
 *
 * Conceptually, we have four types of data sources but all of them are created as data source object:
 * * Main data source: the data source user added in data panel.
 * * Data view: the data view user created in data panel.
 * * Local data source: when multiple widgets connnect to a main data source or a data view, they'll share the same data records. If you need to
 *    use a local data copy, you can create a local data source from a main data source by using `DataSourceManager.getInstance().createLocalDataSource()`.
 * * Local data view: a local data source created from a data view.
 *
 * Data view, local data source or local data view derived from the same main data source will share the same schema, same selection records, but may have different data records,
 * the schema is in main data source only.
 *
 * To share the selection between data source and view, we create a selection data view when create the data source, the selection data source view id is: `${dataSourceId}-selection`.
 * When select, the selected records are copied to the selection data view.
 *
 */
export interface DataSource extends ParentDataSource, ChildDataSource, DataViewDataSource, DataViewOperations, LocalDataSourceOperations, DataSourceEditSourceOperations {
  /**
   * These 3 properties are in app config.
   * Put them here for ease of use.
   */
  id: string
  type: string

  /**
   * The data source JSON object in app config.
   */
  getDataSourceJson: () => IMDataSourceJson
  setDataSourceJson: (dsJson: IMDataSourceJson) => void
  getLabel: () => string

  dataSourceManager: DataSourceManager

  /**
   * Whether a data source contains child data sources.
   * A dataset data source should create its all child data sources before parsing `ready()`.
   */
  isDataSourceSet: boolean

  /**
   * True means the data source is a data view.
   * For local data source, this is false even the local data source is created from a data view.
   */
  isDataView: boolean

  /**
   * True means the data source is a local data source.
   */
  isLocal: boolean

  localId?: string

  /**
   * When current data source is created from an array of records, will save it in `sourceRecords`.
   * These two methods are use to update or get the source data.
   */
  setSourceRecords: (records: DataRecord[]) => void
  getSourceRecords: () => DataRecord[]

  /**
   * The data schema is in "dataSourceJson",
   *    * For data source, use "jimuName" as key, and save the actual field name in the object.
   *    * For data source set, use "jimuChildId" as key, and save the actual child id in the object.
   * In many cases, we need to use the actual "childId" or "fieldName" to access info, so we can use this method to get a reverse schema for ease of use.
   */
  /** @ignore */
  getReversedConfigSchema: () => IMReversedDataSourceSchema

  getRecord: (index: number) => DataRecord
  getRecordById: (id: string) => DataRecord
  /**
   * When current data source is selection view, use `useNoSelectionView` to indicate whether return records in on_selection view when real selection is empty.
   * The default value is true.
   */
  getRecords: (useNoSelectionView?: boolean) => DataRecord[]
  /**
   * If selected records are not loaded in the current data source, will concat them to the end of records array.
   * E.g. record 1 is selected in data view 1, record 1 is not loaded in data view 2 (record 1 actually matches query parmas of data view 2),
   *      dataView2.getRecordsWithSelection() will return all loaded records in data view 2 and record 1.
   */
  getRecordsWithSelection: () => DataRecord[]

  /**
   * Update the records in the data source object only, does not update the source data.
   * See {@link DataSourceEditSourceOperations.updateRecords}
   */
  setRecords: (records: DataRecord[]) => void

  getSelectedRecords?: () => DataRecord[]
  getSelectedRecordIndexes?: () => number[]
  getSelectedRecordIds?: () => string[]
  nextRecord?: () => DataRecord
  prevRecord?: () => DataRecord

  /**
   * Select record by index.
   */
  selectRecord?: (index: number) => void
  selectRecords?: (indexes: number[]) => void

  /** The total records count depends on the current query */
  count?: number

  /**
   * JsonData may come from SSR, and the data uses jimuFieldName as key.
   */
  /** @ignore */
  setJsonData: (jsonData: any[]) => void

  /**
   * When select record by id, we can pass in the records. So when the selected records are not in the data source, we can add them in.
   */
  selectRecordById?: (id: string, record?: DataRecord) => void
  selectRecordsByIds?: (ids: string[], records?: DataRecord[]) => void
  /**
   * Only clear records, don't clear source data, version in datat source info will be added.
   */
  clearRecords?: () => void
  /**
   * @ignore
   * Clear records but don't add version in data source info.
   */
  clearRecordsNotAddVersion?: () => void
  clearSelection?: () => void
  /**
   * @ignore
   * Clear source records and records, both source version and version in data source info will be added.
   */
  clearSourceRecords: () => void
  /**
   * @ignore
   * Clear source records and records, neither source version nor version will be added.
   */
  clearSourceRecordsNotAddVersion: () => void

  /**
   * The schema returned here is the merged result of the configured schema and the fetched schema.
   */
  getSchema: () => IMDataSourceSchema
  setSchema: (schema: IMDataSourceSchema) => void

  /**
   * The schema contains all fields defined in the actual service. This method will return the fields
   * user configured in the widget which generates output data source.
   */
  getSelectedFields: () => string[] // jimuName
  setSelectedFields: (jimuNames: string[]) => void

  /**
   * Fetch data schema from an actual data source. If it's a statistic data source, we won't fetch schema.
   */
  fetchSchema: () => Promise<IMDataSourceSchema>

  getFetchedSchema: () => IMDataSourceSchema
  setFetchedSchema: (schema: IMDataSourceSchema) => void

  getStatus: () => DataSourceStatus
  setStatus?: (status: DataSourceStatus) => void

  getCountStatus: () => DataSourceStatus
  setCountStatus?: (status: DataSourceStatus) => void

  getVersion: () => number
  addVersion?: () => void

  getSelectedRecordIdsFromInfo: () => ImmutableArray<string>
  setSelectedRecordIdsToInfo?: (ids: string[], triggerDataSource: DataSource) => void

  /**
   * When current data source is created from an array of records, will save it in `sourceRecords`.
   * Return the version of `sourceRecords`.
   */
  getSourceVersion: () => number
  /**
   * When current data source is created from an array of records, will save it in `sourceRecords`.
   * Add the version of `sourceRecords`.
   * `setSourceRecords` will add the version by default.
   */
  addSourceVersion: () => void

  getIdField: () => string

  destroy: () => void

  /**
   * Ready is resolved means the data source instance is ready for use.
   */
  ready: () => Promise<void | any>

  getInfo: () => IMDataSourceInfo

  /**
   * Return null means the data source is a non-spatial data source.
   * @ignore
   */
  getGeometryType: () => GeometryType

  /**
   * For most of the widget output data source, it has an original data source from which it's generated.
   * For the configured data source, return null.
   * @ignore
   */
  getOriginDataSources?: () => DataSource[]

  /**
   * Return the derived data views and local data sources.
   */
  getAllDerivedDataSources: () => DataSource[]

  /**
   * Whether listen selected records from other data sources which are derived from the same main data source.
   * If true, will update selected record ids of current data source info when selecting records via other derived data sources.
   * If false, won't change selected record ids when selecting records via other derived data sources. Will update selected record ids only when selecting records via current data source itself.
   *
   * Main data source and its data views will listen selected records by default, local data source won't listen selected records by default.
   */
  setListenSelection: (listen: boolean) => void
  getListenSelection: () => boolean
}

/**
 * `QueriableDataSource` extends `DataSource` and add query capability. A queriable data source must
 * have an `URL` to execute the query.
 *
 * The current default query implementation supports pagination. It allows mulitple widgets to apply queries on the same data source,
 * all of which are merged by using the `AND` logic operator.
 *
 * When execute a query, in addition to the passed in query parameters, all configured queries and
 * all other widgets applied queries are merged by using the `AND` logic operator.
 *
 * When a query is executed against a data view, the query from its main data source is used as well.
 */
export interface QueriableDataSource extends DataSource {
  url: string
  lastUpdateTime: Date

  /**
   * Execute the query against the service and update the internal data records, pagination is supported.
   * When call this method, the real query is returnd by `getRealQueryParams`.
   *
   * Pagination:
   * The pagination properties in the passed in query parameter may be not the same as the real query pagination that is sent to the service.
   * The real query pagination is defined in the data source setting.
   */
  load: (query: QueryParams, options?: QueryOptions) => Promise<DataRecord[]>

  /**
   * Load record by id, do not consider other queries.
   */
  loadById: (id: string, refresh?: boolean) => Promise<DataRecord>

  /** Load the records count. */
  loadCount: (query: QueryParams, options?: QueryOptions) => Promise<number>

  /**
   * Update the data source query without executing the actual query.
   */
  updateQueryParams: (query: QueryParams, widgetId: string) => void

  /**
   * Get the current query parameters. The current query parameters contain all applied queries.
   */
  getCurrentQueryParams: (excludeOption?: WidgetDataSourcePair) => QueryParams
  getCurrentQueryId: () => string

  /** Get the queries applied in runtime. If the excludeWidgetId is passed in, the queries of this widget will be excluded. */
  getRuntimeQueryParams: (excludeWidgetId?: string) => QueryParams
  /**
   * Get the user config query parameters.
   */
  getConfigQueryParams: () => QueryParams

  /** Get the query parameters configured in remote (not in exb). */
  getRemoteQueryParams: () => QueryParams

  /**
   * Merge the new query to base query by using `AND`, and return the merged result.
   * If any query is undefined/null, it will be ignored.
   */
  mergeQueryParams: (baseQuery: QueryParams, newQuery: QueryParams) => QueryParams

  /**
   * When do query/load, we do not fire the query request directly. Instead, we'll consider the data source's config/current query parameter.
   *  * For load: we'll merge the configured query parameter if it has, and all widget applied queries.
   *  * For query, we'll merge the current query parameter and the configured query parameter it has.
   */
  getRealQueryParams: (query: QueryParams, flag: 'query' | 'load', options?: QueryOptions) => QueryParams

  /**
   * Execute query against the service only, do NOT update the internal data records.
   * The actural query parameters are generated by `getRealQueryParams`.
   *
   * To query count, please use `queryCount`.
   */
  query: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>

  queryById: (id: string) => Promise<DataRecord>

  queryCount: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>

  /**
   * The page size here defines the records this method returns, which are not the actual query pageSize. Will use a fixed pageSize to query and cache data.
   * `useNoSelectionView` is same as parameter in `getRecords`.
   */
  getRecordsByPage: (page: number, pageSize: number, useNoSelectionView?: boolean) => DataRecord[]
  /**
   * If selected records are not loaded in the current data source, will concat them to the end of records array.
   * See {@link getRecordsWithSelection} for details.
   */
  getRecordsByPageWithSelection: (page: number, pageSize: number) => DataRecord[]

  getPagesData: () => {[page: number]: DataRecord[]}
  setPagesData: (pages: {[page: number]: DataRecord[]}) => void

  /**
   * Get real query page depends on the widget's request page.
   */
  getRealQueryPages: (pageSize: number, page: number) => number[]

  getQueryPageSize: () => number

  /**
   * Null means there is no record count limit, and will return all records from the service.
   */
  getMaxRecordCount: () => number

  // TODO add/update/delete multiple records
  /** @ignore */
  getSaveStatus: () => DataSourceStatus
  /** @ignore */
  setSaveStatus?: (status: DataSourceStatus) => void

  /** Override parent interface to get correct type. */
  getDataViews: () => QueriableDataSource[]
  getDataView: (dataViewId: string) => QueriableDataSource
  getMainDataSource: () => QueriableDataSource

  /** If the return value > 0, auto refresh is enabled. */
  getAutoRefreshInterval: () => number
  getLastRefreshTime: () => Date
  startAutoRefresh: () => void
  stopAutoRefresh: () => void
  allowToExportData: () => Promise<boolean>
}

/** @ignore */
export interface LoadableDataSource extends DataSource {
  url: string

  /**
   * Load all data records.
   */
  load: () => Promise<DataRecord[]>
}

/**
 * Parameters of `DataSource`'s constructor.
 */
export interface DataSourceConstructorOptions {
  /** The data source id. */
  id: string

  /**
   * dataSourceJson or belongToDataSource is either-or option.
   * Pass dataSourceJson will create a main data source.
   * Pass belongToDataSource will create data view or local data source.
   */
  dataSourceJson?: IMDataSourceJson

  /** Data source that the to-be-created data source belongs to. */
  belongToDataSource?: DataSource

  /**
   * If dataViewId exists, a data view will be created.
   */
  dataViewId?: string

  /**
   * if localId exists, a local data source will be created.
   */
  localId?: string

  dataSourceManager?: DataSourceManager

  parentDataSource?: DataSource
  jimuChildId?: string
   /**
   * If all of the data is holded in the data source instance, put the data in the source records.
   * For others, the data may come from AGOL/portal item or a remote database.
   *
   * Only main data source or selection view will save source records,
   * if current data source is a view of selection view, will use selection view's source records, else,
   * will use main data source's source records.
   */
  sourceRecords?: FeatureDataRecord[]
}

/**
 * @ignore
 */
export class DataSourceError extends Error {
  dataSourceId: string
  constructor (id, message) {
    super(message)
    this.dataSourceId = id
  }
}

/** @ignore */
export interface CodedValue{
  value: string | number
  label: string
}

/** *********************************************************** Data sources ***********************************************/
/**
 * Record of feature layer data source.
 */

export interface FeatureDataRecord extends DataRecord{
  feature: IFeature | __esri.Graphic
  dataSource: FeatureLayerDataSource | SceneLayerDataSource
  attachmentInfos: AttachmentInfo[]
  queryAttachments: (attachmentTypes?: string[]) => Promise<AttachmentInfo[]>
  getSymbolPreviewHTML: () => Promise<HTMLElement>
  getData: () => {[key: string]: any}
  getFormattedFieldValue: (jimuFieldName: string, intl: IntlShape) => string
  getDataBeforeMapping: () => {[key: string]: any}
  getOriginData: () => {[key: string]: any}
  toJson: () => IFeature | __esri.Graphic
  getId: () => string
  setId: (id: string) => void
  getGeometry: () => IGeometry
  setFeature: (feature: IFeature | __esri.Graphic) => void
  getFeature: () => IFeature | __esri.Graphic
}

export interface SimpleLocalDataSource extends DataSource{
  type: DataSourceTypes.SimpleLocal
}
export interface CsvDataSource extends LoadableDataSource{
  type: DataSourceTypes.CSV
  doLoad: () => Promise<DataRecord[]>
}

interface FeatureLayerGDBVersion{
  getGDBVersion: () => string
  changeGDBVersion: (gdbVersion: string) => void
}

/**
 * Feature layer data source is created from a single feature layer of feature service, map service or webmap/webscene.
 */
export interface FeatureLayerDataSource extends QueriableDataSource, FeatureLayerGDBVersion{
  type: DataSourceTypes.FeatureLayer
  url: string
  jimuFeatureLayerViews?: {[jimuFeatureLayerViewId: string]: JimuFeatureLayerView}
  portalUrl?: string
  itemId?: string
  layerId?: string
  layer?: __esri.FeatureLayer
  load: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<DataRecord[]>
  loadCount: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<number>
  query: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>
  queryCount: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>
  queryById: (id: string) => Promise<FeatureDataRecord>
  selectRecordById: (id: string, record?: FeatureDataRecord) => void
  selectRecordsByIds: (ids: string[], records?: FeatureDataRecord[]) => void
  getIdField: () => string
  getGeometryType: () => GeometryType
  setJsonData: (data: Array<IFeature | __esri.Graphic>) => void
  getConfigQueryParams: () => FeatureLayerQueryParams
  mergeQueryParams: (baseQuery: FeatureLayerQueryParams, newQuery: FeatureLayerQueryParams) => FeatureLayerQueryParams
  getRealQueryParams: (query, flag: 'query' | 'load', options?: QueryOptions) => FeatureLayerQueryParams
  fetchSchema: () => Promise<IMDataSourceSchema>
  getLayerDefinition: () => ServiceDefinition
  getFieldCodedValueList: (jimuFieldName: string, record?: FeatureDataRecord) => CodedValue[]
  setAssociatedDataSource: (associatedDataSource: SceneLayerDataSource) => void
  getAssociatedDataSource: () => SceneLayerDataSource
  getPopupInfo: () => Promise<IPopupInfo>
  supportSymbol: () => boolean
  supportAttachment: () => boolean
}

/**
 * Group layer data source is created from a group layer of map service or webmap/webscene.
 */
export interface GroupLayerDataSource extends DataSource{
  type: DataSourceTypes.GroupLayer
  layer?: __esri.GroupLayer | __esri.Sublayer
  getServiceDefinition: () => ServiceDefinition
}

/**
 * Feature service data source is created from feature service.
 */
export interface FeatureServiceDataSource extends DataSource{
  type: DataSourceTypes.FeatureService
  getServiceDefinition: () => ServiceDefinition
}

/**
 * Map service data source is created from map service or webmap/webscene.
 */
export interface MapServiceDataSource extends DataSource{
  type: DataSourceTypes.MapService
  layer?: __esri.MapImageLayer | __esri.TileLayer
  getServiceDefinition: () => ServiceDefinition
}

/**
 * Scene service data source is created from scene service or webscene.
 */
export interface SceneServiceDataSource extends DataSource{
  type: DataSourceTypes.SceneService
  getServiceDefinition: () => ServiceDefinition
}

/**
 * Scene layer data source is created from a single scene layer of scene service or webscene.
 */
export interface SceneLayerDataSource extends Omit<FeatureLayerDataSource, 'type' | 'layer' | 'getAssociatedDataSource' | 'setAssociatedDataSource'>{
  type: DataSourceTypes.SceneLayer
  getAssociatedDataSource: () => FeatureLayerDataSource
  getPopupInfo: () => Promise<IPopupInfo>
  layer?: __esri.SceneLayer
}

/**
 * @ignore
 * @deprecated
 */
export interface FeatureQueryDataSource extends FeatureLayerDataSource{}

/** *********************************************************** Data sources ***********************************************/
